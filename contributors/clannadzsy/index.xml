<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clannadzsy on</title><link>https://clannad.icu/contributors/clannadzsy/</link><description>Recent content in clannadzsy on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 21 Mar 2024 01:44:00 +0000</lastBuildDate><atom:link href="https://clannad.icu/contributors/clannadzsy/index.xml" rel="self" type="application/rss+xml"/><item><title>JS获取Shadow DOM中closes 节点</title><link>https://clannad.icu/blog/3082362680/</link><pubDate>Thu, 21 Mar 2024 01:44:00 +0000</pubDate><guid>https://clannad.icu/blog/3082362680/</guid><description>安装 油猴 插件, 在你需要获取的网站, 新建脚本, 填入以下代码, 刷新页面即可
Element.prototype._attachShadow = Element.prototype.attachShadow; Element.prototype.attachShadow = function () { return this._attachShadow({mode:'open'}); };</description></item><item><title>WindMouse，一种生成类人鼠标运动的算法</title><link>https://clannad.icu/blog/1190727728/</link><pubDate>Sun, 17 Mar 2024 06:15:02 +0000</pubDate><guid>https://clannad.icu/blog/1190727728/</guid><description>WindMouse import numpy as np sqrt3 = np.sqrt(3) sqrt5 = np.sqrt(5) def wind_mouse(start_x, start_y, dest_x, dest_y, G_0=9, W_0=3, M_0=15, D_0=12, move_mouse=lambda x,y: None): ''' WindMouse algorithm. Calls the move_mouse kwarg with each new step. Released under the terms of the GPLv3 license. G_0 - magnitude of the gravitational fornce W_0 - magnitude of the wind force fluctuations M_0 - maximum step size (velocity clip threshold) D_0 - distance where wind behavior changes from random to damped ''' current_x,current_y = start_x,start_y v_x = v_y = W_x = W_y = 0 while (dist:=np.</description></item><item><title>The Golang Chronicles From Ai</title><link>https://clannad.icu/blog/3231606058/</link><pubDate>Fri, 25 Aug 2023 02:53:11 +0000</pubDate><guid>https://clannad.icu/blog/3231606058/</guid><description>Title: &amp;ldquo;The Golang Chronicles&amp;rdquo;
Chapter 1: The Mysterious Codex
In the bustling city of Devoria, where the clatter of steam-powered machines filled the air, lived a young prodigy named Alaric. He was known throughout the city as the most brilliant programmer, his skills unmatched in the world of technology. Alaric had an insatiable hunger for knowledge and was always seeking the next great challenge.
One fateful day, Alaric received a cryptic message on his antique computer, a relic from a bygone era.</description></item><item><title>The Golang Chronicles From Ai</title><link>https://clannad.icu/blog/3231606058/</link><pubDate>Fri, 25 Aug 2023 02:53:11 +0000</pubDate><guid>https://clannad.icu/blog/3231606058/</guid><description>Title: &amp;ldquo;The Golang Chronicles&amp;rdquo;
Chapter 1: The Mysterious Codex
In the bustling city of Devoria, where the clatter of steam-powered machines filled the air, lived a young prodigy named Alaric. He was known throughout the city as the most brilliant programmer, his skills unmatched in the world of technology. Alaric had an insatiable hunger for knowledge and was always seeking the next great challenge.
One fateful day, Alaric received a cryptic message on his antique computer, a relic from a bygone era.</description></item><item><title>提高 Golang 并发编程能力的必备利器：深入学习 sync.Cond 类型</title><link>https://clannad.icu/blog/1539748842/</link><pubDate>Sat, 06 May 2023 03:02:01 +0000</pubDate><guid>https://clannad.icu/blog/1539748842/</guid><description>Go 语言的 sync 包提供了一系列同步原语，其中 sync.Cond 就是其中之一。sync.Cond 的作用是在多个 goroutine 之间进行条件变量的同步。本文将深入探讨 sync.Cond 的实现原理和使用方法，帮助大家更好地理解和应用 sync.Cond。
sync.Cond 的基本概念 1.1 条件变量 条件变量是一种同步机制，用于在多个 goroutine 之间进行同步。条件变量通常是和互斥锁一起使用的，用于等待某个条件的出现。 在 Go 语言中，条件变量由 sync.Cond 类型实现。它提供了两个主要的方法：Wait 和 Signal/Broadcast。Wait 方法用于等待条件变量的出现，Signal/Broadcast 方法用于通知等待中的 goroutine。 1.2 互斥锁 互斥锁是一种用于控制对共享资源访问的同步机制。它能够保证同一时刻只有一个 goroutine 能够访问共享资源。 在 Go 语言中，互斥锁由 sync.Mutex 类型实现。它提供了两个主要的方法：Lock 和 Unlock。Lock 方法用于加锁，保证同一时刻只有一个 goroutine 能够访问共享资源；Unlock 方法用于解锁，允许其他 goroutine 访问共享资源。 1.3 条件变量的实现原理 条件变量的实现原理基于互斥锁和 goroutine 队列。 假设有一个条件变量 cond，初始时它没有被触发。当一个 goroutine 调用 cond.Wait() 方法时，它会加锁并将自己加入到 cond 的 goroutine 队列中。接着，它会解锁并进入睡眠状态，等待被唤醒。 当另一个 goroutine 调用 cond.Signal() 或者 cond.Broadcast() 方法时，它会重新加锁，并从 cond 的 goroutine 队列中选择一个 goroutine 唤醒。被唤醒的 goroutine 会重新加锁，然后继续执行。 需要注意的是，被唤醒的 goroutine 并不会立即执行，它会等待重新获得锁之后才会继续执行。 sync.</description></item><item><title>解决 Android 7 及以上的安卓系统模拟器, 无法抓包 https 请求</title><link>https://clannad.icu/blog/3640029440/</link><pubDate>Sat, 06 May 2023 02:09:38 +0000</pubDate><guid>https://clannad.icu/blog/3640029440/</guid><description>在Android 7及以上版本中，由于系统对证书的限制，使用抓包软件（如Fiddler、Charles）进行HTTPS抓包会遇到困难。下面介绍一种解决方案。
生成证书 首先需要将证书生成在本地电脑上，可使用cer或pem格式。然后通过openssl计算证书hash值：
cer格式证书 openssl x509 -inform DER -subject_hash_old -in &amp;lt;证书文件.cer&amp;gt; pem格式证书 openssl x509 -inform PEM -subject_hash_old -in &amp;lt;证书文件.pem&amp;gt; 然后生成系统预设格式的证书文件（记得加上&amp;quot;.0&amp;quot;），如果hash值一样，则另一个设置成.1：
cer格式 openssl x509 -inform DER -text -in xxx.cer &amp;gt; hash值.0 pem格式 openssl x509 -inform PEM -text -in xxx.pem &amp;gt; hash值.0 安装证书 将证书安装到系统中：
手机连接电脑，使用adb命令将手机连接到电脑。 禁用系统验证： adb root adb disable-verity adb reboot adb root adb remount 将证书文件push到手机： adb push &amp;lt;证书文件hash.0&amp;gt; /system/etc/security/cacerts/ 重启手机。 如果在adb disable-verity这步出现失败，则需要进行提权：</description></item><item><title>Golang并发时报错connection Reset by Peer</title><link>https://clannad.icu/blog/630506263/</link><pubDate>Thu, 02 Mar 2023 01:46:42 +0000</pubDate><guid>https://clannad.icu/blog/630506263/</guid><description>当使用Golang进行并发时，有时可能会遇到connection reset by peer的错误。最开始可能会认为这是Golang的HTTP包的问题，但最终在Github中找到了解决方法。
首先，需要知道在操作系统中，打开的文件数、打开的socket数以及正在监听的端口数等统称为句柄数。操作系统对每个用户的句柄数都有默认限制，例如root用户默认限制为4096个句柄数。
因此，当Golang并发时报错connection reset by peer时，并不是因为你编写的程序有问题，而是操作系统设置的问题。
为了避免操作系统的文件句柄数限制goroutine的socket并发数量，我们需要增大程序运行时所使用用户的句柄数。如果你的进程使用root用户运行，那么需要增大root用户可打开的句柄数。
增加root用户可打开的文件数的方法如下：
打开/etc/security/limits.conf文件：
$ vi /etc/security/limits.conf 在文件末尾添加以下两行：
root - nofile 65535 root - nproc 30000 让配置生效：
$ sysctl -p</description></item><item><title>[Python] 卖家精灵 Chrome 插件 Js 逆向</title><link>https://clannad.icu/blog/2494707647/</link><pubDate>Fri, 25 Mar 2022 02:05:38 +0000</pubDate><guid>https://clannad.icu/blog/2494707647/</guid><description>chrome://version, 查看 个人资料路径 C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default 打开插件所在文件夹: Extensions, 目录如下:
C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions chrome://extensions/ 查看卖家精灵插件 ID
ID：lnbmbgocenenhhhdojdielgnmeflbnfb 根据插件ID, 寻找对应的文件夹并使用编辑器打开
卖家精灵产品查询分析流程
URL分析
tk 参数分析
B00DQFGJR4 不变, 更改 tk 的值, 提示无法使用此功能, 因此, tk 参数并不是随机生成的, 而是与 asin 有关
使用编辑器, 全局搜索 tk , 发现 tk 参数, 都是由 N.a.s2Tkk(t) 方法生成
static asins(e, t) { return ve(this, void 0, void 0, (function*() { const a = yield n.</description></item><item><title>[Go] 数组, 切片的长度与容量</title><link>https://clannad.icu/blog/4217449500/</link><pubDate>Tue, 12 Oct 2021 07:18:30 +0000</pubDate><guid>https://clannad.icu/blog/4217449500/</guid><description>来源: Capacity and length of a slice in Go
数组 数组是具有**size**相同值的某个对象的索引集合**type**，声明为：
数组的属性 数组有固定大小，不能调整大小。切片可以调整大小。 数组的类型包括其大小。的[4]int数组类型是不同于[5]int，并且它们不能相比。 初始化一个数组，var name [size]type创建一个size类型元素的集合，type每个元素都是给定的零值type。 数组按值传递。这意味着当您将一个数组分配给另一个数组时，您将制作其内容的新副本： 切片 var name []type
切片的属性 append()调用函数时，切片会自动调整大小。 切片是不可比较的，简单的相等比较a == b是不可能的。查看如何比较切片。 用 初始化切片var name []type会创建一个nil长度和容量等于 0 且没有底层数组的切片。看看nil 和 empty slice 有什么区别。 就像数组（以及 Go 中的所有内容）一样，切片按值传递。当分配一个切片到一个新的变量，则ptr，len以及cap被复制，包括ptr指针将指向同一底层数组。如果修改复制的切片，则会修改相同的共享数组，这将使旧切片和新切片中的所有更改都可见：</description></item><item><title>[Go] 中的陷阱</title><link>https://clannad.icu/blog/3160062725/</link><pubDate>Fri, 24 Sep 2021 03:43:43 +0000</pubDate><guid>https://clannad.icu/blog/3160062725/</guid><description>字符串的长度与数量
// Number of Bytes package main import &amp;quot;fmt&amp;quot; func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(len(data)) } // 7 // 在 Go 中，字符串是 UTF-8 编码的，这意味着每个称为 rune 的字符可以是 1 到 4 个字节长。这里，字符 ♥ 占用 3 个字节，因此字符串的总长度为 7。 // Number of Runes package main import ( &amp;quot;fmt&amp;quot; &amp;quot;unicode/utf8&amp;quot; ) func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(utf8.RuneCountInString(data)) } // 5 // 如果要获取字符串中的字符数量，可以使用 unicode/utf8 包。该 RuneCountInString 功能是返回一个字符串的字符数量 用 nil 初始化变量</description></item></channel></rss>