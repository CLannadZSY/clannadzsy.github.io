<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clannadzsy on</title><link>https://clannad.icu/contributors/clannadzsy/</link><description>Recent content in clannadzsy on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sat, 06 May 2023 03:02:01 +0000</lastBuildDate><atom:link href="https://clannad.icu/contributors/clannadzsy/index.xml" rel="self" type="application/rss+xml"/><item><title>提高 Golang 并发编程能力的必备利器：深入学习 sync.Cond 类型</title><link>https://clannad.icu/blog/1539748842/</link><pubDate>Sat, 06 May 2023 03:02:01 +0000</pubDate><guid>https://clannad.icu/blog/1539748842/</guid><description>Go 语言的 sync 包提供了一系列同步原语，其中 sync.Cond 就是其中之一。sync.Cond 的作用是在多个 goroutine 之间进行条件变量的同步。本文将深入探讨 sync.Cond 的实现原理和使用方法，帮助大家更好地理解和应用 sync.Cond。
sync.Cond 的基本概念 1.1 条件变量 条件变量是一种同步机制，用于在多个 goroutine 之间进行同步。条件变量通常是和互斥锁一起使用的，用于等待某个条件的出现。 在 Go 语言中，条件变量由 sync.Cond 类型实现。它提供了两个主要的方法：Wait 和 Signal/Broadcast。Wait 方法用于等待条件变量的出现，Signal/Broadcast 方法用于通知等待中的 goroutine。 1.2 互斥锁 互斥锁是一种用于控制对共享资源访问的同步机制。它能够保证同一时刻只有一个 goroutine 能够访问共享资源。 在 Go 语言中，互斥锁由 sync.Mutex 类型实现。它提供了两个主要的方法：Lock 和 Unlock。Lock 方法用于加锁，保证同一时刻只有一个 goroutine 能够访问共享资源；Unlock 方法用于解锁，允许其他 goroutine 访问共享资源。 1.3 条件变量的实现原理 条件变量的实现原理基于互斥锁和 goroutine 队列。 假设有一个条件变量 cond，初始时它没有被触发。当一个 goroutine 调用 cond.Wait() 方法时，它会加锁并将自己加入到 cond 的 goroutine 队列中。接着，它会解锁并进入睡眠状态，等待被唤醒。 当另一个 goroutine 调用 cond.Signal() 或者 cond.Broadcast() 方法时，它会重新加锁，并从 cond 的 goroutine 队列中选择一个 goroutine 唤醒。被唤醒的 goroutine 会重新加锁，然后继续执行。 需要注意的是，被唤醒的 goroutine 并不会立即执行，它会等待重新获得锁之后才会继续执行。 sync.</description></item><item><title>解决 Android 7 及以上的安卓系统模拟器, 无法抓包 https 请求</title><link>https://clannad.icu/blog/3640029440/</link><pubDate>Sat, 06 May 2023 02:09:38 +0000</pubDate><guid>https://clannad.icu/blog/3640029440/</guid><description>在Android 7及以上版本中，由于系统对证书的限制，使用抓包软件（如Fiddler、Charles）进行HTTPS抓包会遇到困难。下面介绍一种解决方案。
生成证书 首先需要将证书生成在本地电脑上，可使用cer或pem格式。然后通过openssl计算证书hash值：
cer格式证书 openssl x509 -inform DER -subject_hash_old -in &amp;lt;证书文件.cer&amp;gt; pem格式证书 openssl x509 -inform PEM -subject_hash_old -in &amp;lt;证书文件.pem&amp;gt; 然后生成系统预设格式的证书文件（记得加上&amp;quot;.0&amp;quot;），如果hash值一样，则另一个设置成.1：
cer格式 openssl x509 -inform DER -text -in xxx.cer &amp;gt; hash值.0 pem格式 openssl x509 -inform PEM -text -in xxx.pem &amp;gt; hash值.0 安装证书 将证书安装到系统中：
手机连接电脑，使用adb命令将手机连接到电脑。 禁用系统验证： adb root adb disable-verity adb reboot adb root adb remount 将证书文件push到手机： adb push &amp;lt;证书文件hash.0&amp;gt; /system/etc/security/cacerts/ 重启手机。 如果在adb disable-verity这步出现失败，则需要进行提权：</description></item><item><title>Golang并发时报错connection Reset by Peer</title><link>https://clannad.icu/blog/630506263/</link><pubDate>Thu, 02 Mar 2023 01:46:42 +0000</pubDate><guid>https://clannad.icu/blog/630506263/</guid><description>当使用Golang进行并发时，有时可能会遇到connection reset by peer的错误。最开始可能会认为这是Golang的HTTP包的问题，但最终在Github中找到了解决方法。
首先，需要知道在操作系统中，打开的文件数、打开的socket数以及正在监听的端口数等统称为句柄数。操作系统对每个用户的句柄数都有默认限制，例如root用户默认限制为4096个句柄数。
因此，当Golang并发时报错connection reset by peer时，并不是因为你编写的程序有问题，而是操作系统设置的问题。
为了避免操作系统的文件句柄数限制goroutine的socket并发数量，我们需要增大程序运行时所使用用户的句柄数。如果你的进程使用root用户运行，那么需要增大root用户可打开的句柄数。
增加root用户可打开的文件数的方法如下：
打开/etc/security/limits.conf文件：
$ vi /etc/security/limits.conf 在文件末尾添加以下两行：
root - nofile 65535 root - nproc 30000 让配置生效：
$ sysctl -p</description></item><item><title>[Python] 卖家精灵 Chrome 插件 Js 逆向</title><link>https://clannad.icu/blog/2494707647/</link><pubDate>Fri, 25 Mar 2022 02:05:38 +0000</pubDate><guid>https://clannad.icu/blog/2494707647/</guid><description>chrome://version, 查看 个人资料路径 C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default 打开插件所在文件夹: Extensions, 目录如下:
C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions chrome://extensions/ 查看卖家精灵插件 ID
ID：lnbmbgocenenhhhdojdielgnmeflbnfb 根据插件ID, 寻找对应的文件夹并使用编辑器打开
卖家精灵产品查询分析流程
URL分析
tk 参数分析
B00DQFGJR4 不变, 更改 tk 的值, 提示无法使用此功能, 因此, tk 参数并不是随机生成的, 而是与 asin 有关
使用编辑器, 全局搜索 tk , 发现 tk 参数, 都是由 N.a.s2Tkk(t) 方法生成
static asins(e, t) { return ve(this, void 0, void 0, (function*() { const a = yield n.</description></item><item><title>[Go] 数组, 切片的长度与容量</title><link>https://clannad.icu/blog/4217449500/</link><pubDate>Tue, 12 Oct 2021 07:18:30 +0000</pubDate><guid>https://clannad.icu/blog/4217449500/</guid><description>来源: Capacity and length of a slice in Go
数组 数组是具有**size**相同值的某个对象的索引集合**type**，声明为：
数组的属性 数组有固定大小，不能调整大小。切片可以调整大小。 数组的类型包括其大小。的[4]int数组类型是不同于[5]int，并且它们不能相比。 初始化一个数组，var name [size]type创建一个size类型元素的集合，type每个元素都是给定的零值type。 数组按值传递。这意味着当您将一个数组分配给另一个数组时，您将制作其内容的新副本： 切片 var name []type
切片的属性 append()调用函数时，切片会自动调整大小。 切片是不可比较的，简单的相等比较a == b是不可能的。查看如何比较切片。 用 初始化切片var name []type会创建一个nil长度和容量等于 0 且没有底层数组的切片。看看nil 和 empty slice 有什么区别。 就像数组（以及 Go 中的所有内容）一样，切片按值传递。当分配一个切片到一个新的变量，则ptr，len以及cap被复制，包括ptr指针将指向同一底层数组。如果修改复制的切片，则会修改相同的共享数组，这将使旧切片和新切片中的所有更改都可见：</description></item><item><title>[Go] 中的陷阱</title><link>https://clannad.icu/blog/3160062725/</link><pubDate>Fri, 24 Sep 2021 03:43:43 +0000</pubDate><guid>https://clannad.icu/blog/3160062725/</guid><description>字符串的长度与数量
// Number of Bytes package main import &amp;quot;fmt&amp;quot; func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(len(data)) } // 7 // 在 Go 中，字符串是 UTF-8 编码的，这意味着每个称为 rune 的字符可以是 1 到 4 个字节长。这里，字符 ♥ 占用 3 个字节，因此字符串的总长度为 7。 // Number of Runes package main import ( &amp;quot;fmt&amp;quot; &amp;quot;unicode/utf8&amp;quot; ) func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(utf8.RuneCountInString(data)) } // 5 // 如果要获取字符串中的字符数量，可以使用 unicode/utf8 包。该 RuneCountInString 功能是返回一个字符串的字符数量 用 nil 初始化变量</description></item><item><title>A Bits of Unsolicited Advice</title><link>https://clannad.icu/blog/1213148850/</link><pubDate>Thu, 23 Sep 2021 02:05:12 +0000</pubDate><guid>https://clannad.icu/blog/1213148850/</guid><description>A Bits of Unsolicited Advice Being enthusiastic is worth 25 IQ points.
学习如何从那些你不同意, 甚至冒犯你的人身上学习. 看看你是否能从他们的观点中找到真理
Being enthusiastic is worth 25 IQ points.
热情是值得25个IQ点的
Always demand a deadline. A deadline weeds out the extraneous and the ordinary. It prevents you from trying to make it perfect, so you have to make it different. Different is better.
总是要求有一个最后期限, 一个最后期限可以剔除不相干和普通的东西. 它阻止你试图让它变得完美，所以你必须让它变得不同. 不同就是更好.
Don’t be afraid to ask a question that may sound stupid because 99% of the time everyone else is thinking of the same question and is too embarrassed to ask it.</description></item><item><title>[Go] Goroutines 和 Channels 练习</title><link>https://clannad.icu/blog/1624364114/</link><pubDate>Tue, 07 Sep 2021 07:00:14 +0000</pubDate><guid>https://clannad.icu/blog/1624364114/</guid><description>查找奇数和偶数
/* 查找奇数和偶数 下面的程序启动了两个 Goroutine。这两个 Goroutine 现在并发运行。我们创建了两个无缓冲通道，并将它们作为参数传递给 goroutines，其中包含通道接收到的值。 */ package main func main() { nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} chOdd := make(chan int) chEven := make(chan int) go odd(chOdd) go even(chEven) for _, v := range nums { if v%2 == 0 { chEven &amp;lt;- v } else { chOdd &amp;lt;- v } } } func even(ch chan int) { for v := range ch { println(&amp;quot;偶数: &amp;quot;, v) } } func odd(ch chan int) { for v := range ch { println(&amp;quot;奇数: &amp;quot;, v) } } 启动多个 Goroutines，每个 Goroutine 将值添加到 Channel</description></item><item><title>[Go] defer 理解</title><link>https://clannad.icu/blog/218469985/</link><pubDate>Thu, 02 Sep 2021 06:22:13 +0000</pubDate><guid>https://clannad.icu/blog/218469985/</guid><description>什么是 defer defer 是 Go 语言提供的一种用于注册延迟调用的机智, 每一次 defer 都会把函数压入栈中, 当前函数返回前再把延迟函数取出并执行
defer 语句并不会马上执行，而是会进入一个栈，函数 return 前，会按先进后出（FILO）的顺序执行
先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。
踩坑点 使用 defer 最容易采坑的地方是和带命名返回参数的函数一起使用时。
defer 语句定义时, 对外部变量的引用有两种方式
函数参数: 在 defer 定义时就把值传递给 defer, 并缓存起来 闭包引用: 在 defer 函数被取出调用时根据整个上下文确定当前值 理解 return 语句 return 语句不是原子操作，而是被拆成了两步
val = xxx
return
而 defer 语句就是在这两条语句之间执行，也就是
val = xxx
deferFunc
return
实践检验 package main
import &amp;quot;fmt&amp;quot;
func f1() (r int) {
defer func() {
r++
}()
return 0
}
// 拆分 f1
//func f1() (r int) {
//
// // 1.</description></item><item><title>[Go] Interface</title><link>https://clannad.icu/blog/4229706688/</link><pubDate>Mon, 30 Aug 2021 01:59:22 +0000</pubDate><guid>https://clannad.icu/blog/4229706688/</guid><description>interface类型 interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口
package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string loan float32 } type Employee struct { Human company string money float32 } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func (h *Human) Sing(lyrics string) { fmt.Println(&amp;quot;La la, la la la, la la la la la.</description></item></channel></rss>