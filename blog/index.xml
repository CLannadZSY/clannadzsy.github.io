<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on</title><link>https://clannad.icu/blog/</link><description>Recent content in Blogs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 07 Sep 2021 07:00:14 +0000</lastBuildDate><atom:link href="https://clannad.icu/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Goroutines 和 Channels 练习</title><link>https://clannad.icu/blog/1624364114/</link><pubDate>Tue, 07 Sep 2021 07:00:14 +0000</pubDate><guid>https://clannad.icu/blog/1624364114/</guid><description>查找奇数和偶数
/* 查找奇数和偶数 下面的程序启动了两个 Goroutine。这两个 Goroutine 现在并发运行。我们创建了两个无缓冲通道，并将它们作为参数传递给 goroutines，其中包含通道接收到的值。 */ package main func main() { nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} chOdd := make(chan int) chEven := make(chan int) go odd(chOdd) go even(chEven) for _, v := range nums { if v%2 == 0 { chEven &amp;lt;- v } else { chOdd &amp;lt;- v } } } func even(ch chan int) { for v := range ch { println(&amp;quot;偶数: &amp;quot;, v) } } func odd(ch chan int) { for v := range ch { println(&amp;quot;奇数: &amp;quot;, v) } } 启动多个 Goroutines，每个 Goroutine 将值添加到 Channel</description></item><item><title>[Go] defer 理解</title><link>https://clannad.icu/blog/218469985/</link><pubDate>Thu, 02 Sep 2021 06:22:13 +0000</pubDate><guid>https://clannad.icu/blog/218469985/</guid><description>什么是 defer defer 是 Go 语言提供的一种用于注册延迟调用的机智, 每一次 defer 都会把函数压入栈中, 当前函数返回前再把延迟函数取出并执行
defer 语句并不会马上执行，而是会进入一个栈，函数 return 前，会按先进后出（FILO）的顺序执行
先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。
踩坑点 使用 defer 最容易采坑的地方是和带命名返回参数的函数一起使用时。
defer 语句定义时, 对外部变量的引用有两种方式
函数参数: 在 defer 定义时就把值传递给 defer, 并缓存起来 闭包引用: 在 defer 函数被取出调用时根据整个上下文确定当前值 理解 return 语句 return 语句不是原子操作，而是被拆成了两步
val = xxx
return
而 defer 语句就是在这两条语句之间执行，也就是
val = xxx
deferFunc
return
实践检验 package main
import &amp;quot;fmt&amp;quot;
func f1() (r int) {
defer func() {
r++
}()
return 0
}
// 拆分 f1
//func f1() (r int) {
//
// // 1.</description></item><item><title>[Go] Interface</title><link>https://clannad.icu/blog/4229706688/</link><pubDate>Mon, 30 Aug 2021 01:59:22 +0000</pubDate><guid>https://clannad.icu/blog/4229706688/</guid><description>interface类型 interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口
package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string loan float32 } type Employee struct { Human company string money float32 } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func (h *Human) Sing(lyrics string) { fmt.Println(&amp;quot;La la, la la la, la la la la la.</description></item><item><title>[Go] Method</title><link>https://clannad.icu/blog/1110384130/</link><pubDate>Mon, 30 Aug 2021 01:57:38 +0000</pubDate><guid>https://clannad.icu/blog/1110384130/</guid><description>method继承 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func main() { mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;} sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45, &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;} mark.SayHi() sam.SayHi() } method重写 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.</description></item><item><title>[Go] 字符串拼接性能</title><link>https://clannad.icu/blog/3239669741/</link><pubDate>Tue, 24 Aug 2021 02:39:37 +0000</pubDate><guid>https://clannad.icu/blog/3239669741/</guid><description>1. 字符串高效拼接 1.1 为了避免编译器的优化， 首先实现一个生成长度为 n 的随机字符串的函数。 const letterBytes = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 常见的字符串拼接方式， 以下 5 种
// + func plusConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s += str } return s } // fmt.Sprintf func sprintfConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s = fmt.</description></item><item><title>Python 面试题(1)</title><link>https://clannad.icu/blog/1745614505/</link><pubDate>Wed, 02 Jun 2021 06:40:12 +0000</pubDate><guid>https://clannad.icu/blog/1745614505/</guid><description>闭包
def multipliers(): return [lambda x: i * x for i in range(4)] print([m(2) for m in multipliers()]) 正确答案 [6, 6, 6, 6]
错误答案 [0, 2, 4, 6]
这个的原因是 Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。所以结果是，当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，到那时，无论哪个返回的函数被调用，for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。因此一个等于 2 的值被传递进以上代码，它们将返回一个值 6 （比如：3 x 2）。
# 创建一个闭包，通过使用默认参数立即绑定它的参数 def multipliers(): return [lambda x, i=i : i * x for i in range(4)] # 或者使用 functools.partial 函数 from functools import partial from operator import mul def multipliers(): return [partial(mul, i) for i in range(4)] 默认参数值是可变的</description></item><item><title>Scrapy 永不停止的爬虫</title><link>https://clannad.icu/blog/3380200713/</link><pubDate>Tue, 01 Jun 2021 02:34:55 +0000</pubDate><guid>https://clannad.icu/blog/3380200713/</guid><description>在 Scrapy.Spider 中的使用
from scrapy import Request, Spider, signals from scrapy.exceptions import DontCloseSpider class TestSpider(Spider): name = 'test' start_urls = [ 'https://www.baidu.com' ] def parse(self, response, **kwargs): self.logger.info('crawled: %s', response.url) def next_request(self): req = Request( self.start_urls[0], callback=self.parse, dont_filter=True, ) self.crawler.engine.crawl(req, spider=self) def spider_idle(self): self.next_request() self.logger.info('spider idled.') raise DontCloseSpider @classmethod def from_crawler(cls, crawler, *args, **kwargs): spider = super(TestSpider, cls).from_crawler(crawler, *args, **kwargs) crawler.signals.connect(spider.spider_idle, signal=signals.spider_idle) return spider 输出日志
[scrapy.core.engine] INFO: Spider opened [scrapy.</description></item><item><title>单分派泛函数</title><link>https://clannad.icu/blog/612516780/</link><pubDate>Mon, 31 May 2021 07:33:22 +0000</pubDate><guid>https://clannad.icu/blog/612516780/</guid><description>singledispatch 是 PEP443 中引入的
单分派：根据一个参数的类型，以不同方式执行相同的操作的行为 多分派：可根据多个参数的类型选择专门的函数的行为 泛函数：多个函数绑在一起组合成一个泛函数 初步认识
from decimal import Decimal from functools import singledispatch @singledispatch def fun(arg): print(arg) @fun.register(str) def _(arg): print(type(arg), arg) @fun.register(int) def _(arg): print(type(arg), arg) @fun.register(list) def _(arg): print(type(arg), arg) @fun.register(type(None)) def _(arg): print(type(arg), arg) @fun.register(float) @fun.register(Decimal) def fun_num(arg): print(type(arg), arg) if __name__ == '__main__': fun(&amp;quot;Hello, world.&amp;quot;) fun(123) fun(['spam', 'spam', 'eggs', 'spam']) fun(None) fun(1.23) # False print(fun_num is fun) # To access all registered implementations, use the read-only registry attribute print(fun.</description></item><item><title>Single Dispatch Generic Functions</title><link>https://clannad.icu/blog/404388560/</link><pubDate>Thu, 29 Apr 2021 06:25:32 +0000</pubDate><guid>https://clannad.icu/blog/404388560/</guid><description>&amp;quot;&amp;quot;&amp;quot; from Fluent Python 2nd Example 9-19 &amp;quot;&amp;quot;&amp;quot; from functools import singledispatch from collections import abc import fractions import decimal import html import numbers @singledispatch def htmlize(obj: object) -&amp;gt; str: content = html.escape(repr(obj)) return f'&amp;lt;pre&amp;gt;{content}&amp;lt;/pre&amp;gt;' @htmlize.register def _(text: str) -&amp;gt; str: content = html.escape(text).replace('\n', '&amp;lt;br&amp;gt;\n') return f'&amp;lt;p&amp;gt;{content}&amp;lt;/p&amp;gt;' @htmlize.register def _(seq: abc.Sequence) -&amp;gt; str: inner = '&amp;lt;/li&amp;gt;\n&amp;lt;li&amp;gt;'.join(htmlize(item) for item in seq) return '&amp;lt;ul&amp;gt;\n&amp;lt;li&amp;gt;' + inner + '&amp;lt;/li&amp;gt;\n&amp;lt;/ul&amp;gt;' @htmlize.register def _(n: numbers.Integral) -&amp;gt; str: return f'&amp;lt;pre&amp;gt;{n} (0x{n:x})&amp;lt;/pre&amp;gt;' @htmlize.</description></item><item><title>Python何时执行装饰器</title><link>https://clannad.icu/blog/452409391/</link><pubDate>Thu, 29 Apr 2021 02:39:20 +0000</pubDate><guid>https://clannad.icu/blog/452409391/</guid><description>装饰器的一个关键特性是, 它们在被装饰函数定义之后立即运行。这通常是在导入时(即Python加载模块时) # decorator.py decorators = [] def decorator(func): print(f'running decorator {func}') decorators.append(func) return func @decorator def f1(): print('running f1()') @decorator def f2(): print('running f2()') def f3(): print('running f3()') def main(): print('running main()') print('decorators -&amp;gt;', decorators) f1() f2() f3() if __name__ == '__main__': main() running decorator &amp;lt;function f1 at 0x000002AC46B37550&amp;gt; running decorator &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt; running main() decorators -&amp;gt; [&amp;lt;function f1 at 0x000002AC46B37550&amp;gt;, &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt;] running f1() running f2() running f3() 当 decorator.</description></item></channel></rss>