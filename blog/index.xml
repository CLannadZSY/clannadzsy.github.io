<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on</title><link>https://clannad.icu/blog/</link><description>Recent content in Blogs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 30 Aug 2021 01:59:22 +0000</lastBuildDate><atom:link href="https://clannad.icu/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Interface</title><link>https://clannad.icu/blog/4229706688/</link><pubDate>Mon, 30 Aug 2021 01:59:22 +0000</pubDate><guid>https://clannad.icu/blog/4229706688/</guid><description>interface类型 interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口
package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string loan float32 } type Employee struct { Human company string money float32 } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func (h *Human) Sing(lyrics string) { fmt.Println(&amp;quot;La la, la la la, la la la la la.</description></item><item><title>Method</title><link>https://clannad.icu/blog/1110384130/</link><pubDate>Mon, 30 Aug 2021 01:57:38 +0000</pubDate><guid>https://clannad.icu/blog/1110384130/</guid><description>method继承 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func main() { mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;} sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45, &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;} mark.SayHi() sam.SayHi() } method重写 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.</description></item><item><title>[Go] 字符串拼接性能</title><link>https://clannad.icu/blog/3239669741/</link><pubDate>Tue, 24 Aug 2021 02:39:37 +0000</pubDate><guid>https://clannad.icu/blog/3239669741/</guid><description>[Go]-字符串拼接性能 1. 字符串高效拼接 1.1 为了避免编译器的优化， 首先实现一个生成长度为 n 的随机字符串的函数。 const letterBytes = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 常见的字符串拼接方式， 以下 5 种
// + func plusConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s += str } return s } // fmt.Sprintf func sprintfConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s = fmt.</description></item><item><title>Python 面试题(1)</title><link>https://clannad.icu/blog/1745614505/</link><pubDate>Wed, 02 Jun 2021 06:40:12 +0000</pubDate><guid>https://clannad.icu/blog/1745614505/</guid><description>闭包
def multipliers(): return [lambda x: i * x for i in range(4)] print([m(2) for m in multipliers()]) 正确答案 [6, 6, 6, 6]
错误答案 [0, 2, 4, 6]
这个的原因是 Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。所以结果是，当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，到那时，无论哪个返回的函数被调用，for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。因此一个等于 2 的值被传递进以上代码，它们将返回一个值 6 （比如：3 x 2）。
# 创建一个闭包，通过使用默认参数立即绑定它的参数 def multipliers(): return [lambda x, i=i : i * x for i in range(4)] # 或者使用 functools.partial 函数 from functools import partial from operator import mul def multipliers(): return [partial(mul, i) for i in range(4)] 默认参数值是可变的</description></item><item><title>Scrapy 永不停止的爬虫</title><link>https://clannad.icu/blog/3380200713/</link><pubDate>Tue, 01 Jun 2021 02:34:55 +0000</pubDate><guid>https://clannad.icu/blog/3380200713/</guid><description>在 Scrapy.Spider 中的使用
from scrapy import Request, Spider, signals from scrapy.exceptions import DontCloseSpider class TestSpider(Spider): name = 'test' start_urls = [ 'https://www.baidu.com' ] def parse(self, response, **kwargs): self.logger.info('crawled: %s', response.url) def next_request(self): req = Request( self.start_urls[0], callback=self.parse, dont_filter=True, ) self.crawler.engine.crawl(req, spider=self) def spider_idle(self): self.next_request() self.logger.info('spider idled.') raise DontCloseSpider @classmethod def from_crawler(cls, crawler, *args, **kwargs): spider = super(TestSpider, cls).from_crawler(crawler, *args, **kwargs) crawler.signals.connect(spider.spider_idle, signal=signals.spider_idle) return spider 输出日志
[scrapy.core.engine] INFO: Spider opened [scrapy.</description></item><item><title>单分派泛函数</title><link>https://clannad.icu/blog/612516780/</link><pubDate>Mon, 31 May 2021 07:33:22 +0000</pubDate><guid>https://clannad.icu/blog/612516780/</guid><description>singledispatch 是 PEP443 中引入的
单分派：根据一个参数的类型，以不同方式执行相同的操作的行为 多分派：可根据多个参数的类型选择专门的函数的行为 泛函数：多个函数绑在一起组合成一个泛函数 初步认识
from decimal import Decimal from functools import singledispatch @singledispatch def fun(arg): print(arg) @fun.register(str) def _(arg): print(type(arg), arg) @fun.register(int) def _(arg): print(type(arg), arg) @fun.register(list) def _(arg): print(type(arg), arg) @fun.register(type(None)) def _(arg): print(type(arg), arg) @fun.register(float) @fun.register(Decimal) def fun_num(arg): print(type(arg), arg) if __name__ == '__main__': fun(&amp;quot;Hello, world.&amp;quot;) fun(123) fun(['spam', 'spam', 'eggs', 'spam']) fun(None) fun(1.23) # False print(fun_num is fun) # To access all registered implementations, use the read-only registry attribute print(fun.</description></item><item><title>Single Dispatch Generic Functions</title><link>https://clannad.icu/blog/404388560/</link><pubDate>Thu, 29 Apr 2021 06:25:32 +0000</pubDate><guid>https://clannad.icu/blog/404388560/</guid><description>&amp;quot;&amp;quot;&amp;quot; from Fluent Python 2nd Example 9-19 &amp;quot;&amp;quot;&amp;quot; from functools import singledispatch from collections import abc import fractions import decimal import html import numbers @singledispatch def htmlize(obj: object) -&amp;gt; str: content = html.escape(repr(obj)) return f'&amp;lt;pre&amp;gt;{content}&amp;lt;/pre&amp;gt;' @htmlize.register def _(text: str) -&amp;gt; str: content = html.escape(text).replace('\n', '&amp;lt;br&amp;gt;\n') return f'&amp;lt;p&amp;gt;{content}&amp;lt;/p&amp;gt;' @htmlize.register def _(seq: abc.Sequence) -&amp;gt; str: inner = '&amp;lt;/li&amp;gt;\n&amp;lt;li&amp;gt;'.join(htmlize(item) for item in seq) return '&amp;lt;ul&amp;gt;\n&amp;lt;li&amp;gt;' + inner + '&amp;lt;/li&amp;gt;\n&amp;lt;/ul&amp;gt;' @htmlize.register def _(n: numbers.Integral) -&amp;gt; str: return f'&amp;lt;pre&amp;gt;{n} (0x{n:x})&amp;lt;/pre&amp;gt;' @htmlize.</description></item><item><title>Python何时执行装饰器</title><link>https://clannad.icu/blog/452409391/</link><pubDate>Thu, 29 Apr 2021 02:39:20 +0000</pubDate><guid>https://clannad.icu/blog/452409391/</guid><description>装饰器的一个关键特性是, 它们在被装饰函数定义之后立即运行。这通常是在导入时(即Python加载模块时) # decorator.py decorators = [] def decorator(func): print(f'running decorator {func}') decorators.append(func) return func @decorator def f1(): print('running f1()') @decorator def f2(): print('running f2()') def f3(): print('running f3()') def main(): print('running main()') print('decorators -&amp;gt;', decorators) f1() f2() f3() if __name__ == '__main__': main() running decorator &amp;lt;function f1 at 0x000002AC46B37550&amp;gt; running decorator &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt; running main() decorators -&amp;gt; [&amp;lt;function f1 at 0x000002AC46B37550&amp;gt;, &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt;] running f1() running f2() running f3() 当 decorator.</description></item><item><title>Function Parameters as References</title><link>https://clannad.icu/blog/4119532816/</link><pubDate>Tue, 27 Apr 2021 02:10:40 +0000</pubDate><guid>https://clannad.icu/blog/4119532816/</guid><description>&amp;quot;&amp;quot;&amp;quot; from Fluent Python 2nd Example 6-11 &amp;quot;&amp;quot;&amp;quot; def f(p1, p2): p1 += p2 return p1 x, y = 1, 2 f(x, y) # x = 1, y = 2 a = [1, 2] b = [3, 4] f(a, b) # a 的值改变了 # a = [1, 2, 3, 4] # b = [3, 4] m = (1, 2) n = (3, 4) f(m, n) # m = (1, 2) # n = (3, 4)</description></item><item><title>List, Tuple, += 问题记录</title><link>https://clannad.icu/blog/2414890336/</link><pubDate>Mon, 26 Apr 2021 07:15:47 +0000</pubDate><guid>https://clannad.icu/blog/2414890336/</guid><description>Building Lists of Lists test_1 = [['1'] * 3 for i in range(3)] test_2 = [['1'] * 3] * 3 test_1[1][1] = 0 test_1 = [['1', '1', '1'], ['1', 0, '1'], ['1', '1', '1']] test_2[1][1] = 0 # 引用了同一对象 test_2 = [['1', 0, '1'], ['1', 0, '1'], ['1', 0, '1']] Tuple, += a = (1, 2, [3, 4]) a[2] += [5, 6] # TypeError: 'tuple' object does not support item assignment print(a) # (1, 2, [3, 4, 5, 6]) # why?</description></item></channel></rss>