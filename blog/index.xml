<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on</title><link>https://clannad.icu/blog/</link><description>Recent content in Blogs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 02 Jun 2021 06:40:12 +0000</lastBuildDate><atom:link href="https://clannad.icu/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 面试题(1)</title><link>https://clannad.icu/blog/1745614505/</link><pubDate>Wed, 02 Jun 2021 06:40:12 +0000</pubDate><guid>https://clannad.icu/blog/1745614505/</guid><description>闭包
def multipliers(): return [lambda x: i * x for i in range(4)] print([m(2) for m in multipliers()]) 正确答案 [6, 6, 6, 6]
错误答案 [0, 2, 4, 6]
这个的原因是 Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。所以结果是，当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，到那时，无论哪个返回的函数被调用，for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。因此一个等于 2 的值被传递进以上代码，它们将返回一个值 6 （比如：3 x 2）。
# 创建一个闭包，通过使用默认参数立即绑定它的参数 def multipliers(): return [lambda x, i=i : i * x for i in range(4)] # 或者使用 functools.partial 函数 from functools import partial from operator import mul def multipliers(): return [partial(mul, i) for i in range(4)] 默认参数值是可变的</description></item><item><title>Scrapy 永不停止的爬虫</title><link>https://clannad.icu/blog/3380200713/</link><pubDate>Tue, 01 Jun 2021 02:34:55 +0000</pubDate><guid>https://clannad.icu/blog/3380200713/</guid><description>在 Scrapy.Spider 中的使用
from scrapy import Request, Spider, signals from scrapy.exceptions import DontCloseSpider class TestSpider(Spider): name = 'test' start_urls = [ 'https://www.baidu.com' ] def parse(self, response, **kwargs): self.logger.info('crawled: %s', response.url) def next_request(self): req = Request( self.start_urls[0], callback=self.parse, dont_filter=True, ) self.crawler.engine.crawl(req, spider=self) def spider_idle(self): self.next_request() self.logger.info('spider idled.') raise DontCloseSpider @classmethod def from_crawler(cls, crawler, *args, **kwargs): spider = super(TestSpider, cls).from_crawler(crawler, *args, **kwargs) crawler.signals.connect(spider.spider_idle, signal=signals.spider_idle) return spider 输出日志
[scrapy.core.engine] INFO: Spider opened [scrapy.</description></item><item><title>单分派泛函数</title><link>https://clannad.icu/blog/612516780/</link><pubDate>Mon, 31 May 2021 07:33:22 +0000</pubDate><guid>https://clannad.icu/blog/612516780/</guid><description>singledispatch 是 PEP443 中引入的
单分派：根据一个参数的类型，以不同方式执行相同的操作的行为 多分派：可根据多个参数的类型选择专门的函数的行为 泛函数：多个函数绑在一起组合成一个泛函数 初步认识
from decimal import Decimal from functools import singledispatch @singledispatch def fun(arg): print(arg) @fun.register(str) def _(arg): print(type(arg), arg) @fun.register(int) def _(arg): print(type(arg), arg) @fun.register(list) def _(arg): print(type(arg), arg) @fun.register(type(None)) def _(arg): print(type(arg), arg) @fun.register(float) @fun.register(Decimal) def fun_num(arg): print(type(arg), arg) if __name__ == '__main__': fun(&amp;quot;Hello, world.&amp;quot;) fun(123) fun(['spam', 'spam', 'eggs', 'spam']) fun(None) fun(1.23) # False print(fun_num is fun) # To access all registered implementations, use the read-only registry attribute print(fun.</description></item><item><title>Single Dispatch Generic Functions</title><link>https://clannad.icu/blog/404388560/</link><pubDate>Thu, 29 Apr 2021 06:25:32 +0000</pubDate><guid>https://clannad.icu/blog/404388560/</guid><description>&amp;quot;&amp;quot;&amp;quot; from Fluent Python 2nd Example 9-19 &amp;quot;&amp;quot;&amp;quot; from functools import singledispatch from collections import abc import fractions import decimal import html import numbers @singledispatch def htmlize(obj: object) -&amp;gt; str: content = html.escape(repr(obj)) return f'&amp;lt;pre&amp;gt;{content}&amp;lt;/pre&amp;gt;' @htmlize.register def _(text: str) -&amp;gt; str: content = html.escape(text).replace('\n', '&amp;lt;br&amp;gt;\n') return f'&amp;lt;p&amp;gt;{content}&amp;lt;/p&amp;gt;' @htmlize.register def _(seq: abc.Sequence) -&amp;gt; str: inner = '&amp;lt;/li&amp;gt;\n&amp;lt;li&amp;gt;'.join(htmlize(item) for item in seq) return '&amp;lt;ul&amp;gt;\n&amp;lt;li&amp;gt;' + inner + '&amp;lt;/li&amp;gt;\n&amp;lt;/ul&amp;gt;' @htmlize.register def _(n: numbers.Integral) -&amp;gt; str: return f'&amp;lt;pre&amp;gt;{n} (0x{n:x})&amp;lt;/pre&amp;gt;' @htmlize.</description></item><item><title>Python何时执行装饰器</title><link>https://clannad.icu/blog/452409391/</link><pubDate>Thu, 29 Apr 2021 02:39:20 +0000</pubDate><guid>https://clannad.icu/blog/452409391/</guid><description>装饰器的一个关键特性是, 它们在被装饰函数定义之后立即运行。这通常是在导入时(即Python加载模块时) # decorator.py decorators = [] def decorator(func): print(f'running decorator {func}') decorators.append(func) return func @decorator def f1(): print('running f1()') @decorator def f2(): print('running f2()') def f3(): print('running f3()') def main(): print('running main()') print('decorators -&amp;gt;', decorators) f1() f2() f3() if __name__ == '__main__': main() running decorator &amp;lt;function f1 at 0x000002AC46B37550&amp;gt; running decorator &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt; running main() decorators -&amp;gt; [&amp;lt;function f1 at 0x000002AC46B37550&amp;gt;, &amp;lt;function f2 at 0x000002AC46B55C10&amp;gt;] running f1() running f2() running f3() 当 decorator.</description></item><item><title>Function Parameters as References</title><link>https://clannad.icu/blog/4119532816/</link><pubDate>Tue, 27 Apr 2021 02:10:40 +0000</pubDate><guid>https://clannad.icu/blog/4119532816/</guid><description>&amp;quot;&amp;quot;&amp;quot; from Fluent Python 2nd Example 6-11 &amp;quot;&amp;quot;&amp;quot; def f(p1, p2): p1 += p2 return p1 x, y = 1, 2 f(x, y) # x = 1, y = 2 a = [1, 2] b = [3, 4] f(a, b) # a 的值改变了 # a = [1, 2, 3, 4] # b = [3, 4] m = (1, 2) n = (3, 4) f(m, n) # m = (1, 2) # n = (3, 4)</description></item><item><title>List, Tuple, += 问题记录</title><link>https://clannad.icu/blog/2414890336/</link><pubDate>Mon, 26 Apr 2021 07:15:47 +0000</pubDate><guid>https://clannad.icu/blog/2414890336/</guid><description>Building Lists of Lists test_1 = [['1'] * 3 for i in range(3)] test_2 = [['1'] * 3] * 3 test_1[1][1] = 0 test_1 = [['1', '1', '1'], ['1', 0, '1'], ['1', '1', '1']] test_2[1][1] = 0 # 引用了同一对象 test_2 = [['1', 0, '1'], ['1', 0, '1'], ['1', 0, '1']] Tuple, += a = (1, 2, [3, 4]) a[2] += [5, 6] # TypeError: 'tuple' object does not support item assignment print(a) # (1, 2, [3, 4, 5, 6]) # why?</description></item><item><title>Hugo 添加评论功能</title><link>https://clannad.icu/blog/2243409341/</link><pubDate>Thu, 15 Apr 2021 20:18:28 +0800</pubDate><guid>https://clannad.icu/blog/2243409341/</guid><description>Hugo 添加评论功能 安装 utterances
layouts/blog/single.html
{{ define &amp;quot;main&amp;quot; }} &amp;lt;div class=&amp;quot;row justify-content-center&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;col-md-12 col-lg-10 col-xl-8&amp;quot;&amp;gt; &amp;lt;article&amp;gt; &amp;lt;div class=&amp;quot;blog-header&amp;quot;&amp;gt; &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt; {{ partial &amp;quot;main/blog-meta.html&amp;quot; . }} &amp;lt;/div&amp;gt; &amp;lt;p class=&amp;quot;lead&amp;quot;&amp;gt;{{ .Params.lead | safeHTML }}&amp;lt;/p&amp;gt; {{ .Content }} &amp;lt;/article&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 添加评论 --&amp;gt; {{ if .Site.Params.utteranc.enable }} &amp;lt;script src=&amp;quot;https://utteranc.es/client.js&amp;quot; repo=&amp;quot;{{ .Site.Params.utteranc.repo }}&amp;quot; issue-term=&amp;quot;{{ .Site.Params.utteranc.issueTerm }}&amp;quot; theme=&amp;quot;{{ .Site.Params.utteranc.theme }}&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot; async&amp;gt; &amp;lt;/script&amp;gt; {{ end }} {{ end }} config/_default/config.</description></item><item><title>装饰器</title><link>https://clannad.icu/blog/3716962172/</link><pubDate>Wed, 14 Apr 2021 20:33:28 +0800</pubDate><guid>https://clannad.icu/blog/3716962172/</guid><description>装饰器 普通装饰器 def logger(func): def wrapper(*args, **kwargs): func_name = func.__name__ print(f'执行了 {func_name} 函数') func(*args, **kwargs) print(f'{func_name} 函数执行完成') return wrapper @logger def add(x, y): print(f'{x} + {y} = {x + y}') add(1, 2) # 执行了 add 函数 # 1 + 2 = 3 # add 函数执行完成 def logger(func): def wrapper(*args, **kwargs): func_name = func.__name__ print(f'执行了 {func_name} 函数') ret = func(*args, **kwargs) print(f'{func_name} 函数执行完成') return ret return wrapper @logger def add(x, y): print(f'{x} + {y} = {x + y}') return x + y add_res = add(1, 2) print(add_res) # 执行了 add 函数 # 1 + 2 = 3 # add 函数执行完成 # 3 定时执行任务装饰器 import schedule, functools, time from schedule import every, repeat, run_pending def run_task(): &amp;quot;&amp;quot;&amp;quot; 定时执行任务 :return: &amp;quot;&amp;quot;&amp;quot; while True: schedule.</description></item><item><title>使用 Hugo + Github + Doks 搭建个人网站</title><link>https://clannad.icu/blog/2726440838/</link><pubDate>Sat, 10 Apr 2021 17:09:32 +0800</pubDate><guid>https://clannad.icu/blog/2726440838/</guid><description>使用 Hugo + Github + Doks 搭建个人网站 1. 安装 Hugo, 参阅官方文档 2. 选择合适的主题 3. 安装主题,二选一即可 Hugo网站的Doks主题: Huog-Doks-Theme
Doks官网: Doks
# Doks child theme git clone https://github.com/h-enk/doks-child-theme.git my-doks-site &amp;amp;&amp;amp; cd my-doks-site # Doks starter theme git clone https://github.com/h-enk/doks.git my-doks-site &amp;amp;&amp;amp; cd my-doks-site # Install dependencies npm install # Start development server # 下载安装主题之后, 无需任何修改, 即可预览主题效果 npm run start 4.</description></item></channel></rss>