<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on</title><link>https://clannad.icu/blog/</link><description>Recent content in Blogs on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Fri, 25 Mar 2022 02:05:38 +0000</lastBuildDate><atom:link href="https://clannad.icu/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>[Python] 卖家精灵 Chrome 插件 Js 逆向</title><link>https://clannad.icu/blog/2494707647/</link><pubDate>Fri, 25 Mar 2022 02:05:38 +0000</pubDate><guid>https://clannad.icu/blog/2494707647/</guid><description>chrome://version, 查看 个人资料路径 C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default 打开插件所在文件夹: Extensions, 目录如下:
C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions chrome://extensions/ 查看卖家精灵插件 ID
ID：lnbmbgocenenhhhdojdielgnmeflbnfb 根据插件ID, 寻找对应的文件夹并使用编辑器打开
卖家精灵产品查询分析流程
URL分析
tk 参数分析
B00DQFGJR4 不变, 更改 tk 的值, 提示无法使用此功能, 因此, tk 参数并不是随机生成的, 而是与 asin 有关
使用编辑器, 全局搜索 tk , 发现 tk 参数, 都是由 N.a.s2Tkk(t) 方法生成
static asins(e, t) { return ve(this, void 0, void 0, (function*() { const a = yield n.</description></item><item><title>[Go] 数组, 切片的长度与容量</title><link>https://clannad.icu/blog/4217449500/</link><pubDate>Tue, 12 Oct 2021 07:18:30 +0000</pubDate><guid>https://clannad.icu/blog/4217449500/</guid><description>来源: Capacity and length of a slice in Go
数组 数组是具有**size**相同值的某个对象的索引集合**type**，声明为：
数组的属性 数组有固定大小，不能调整大小。切片可以调整大小。 数组的类型包括其大小。的[4]int数组类型是不同于[5]int，并且它们不能相比。 初始化一个数组，var name [size]type创建一个size类型元素的集合，type每个元素都是给定的零值type。 数组按值传递。这意味着当您将一个数组分配给另一个数组时，您将制作其内容的新副本： 切片 var name []type
切片的属性 append()调用函数时，切片会自动调整大小。 切片是不可比较的，简单的相等比较a == b是不可能的。查看如何比较切片。 用 初始化切片var name []type会创建一个nil长度和容量等于 0 且没有底层数组的切片。看看nil 和 empty slice 有什么区别。 就像数组（以及 Go 中的所有内容）一样，切片按值传递。当分配一个切片到一个新的变量，则ptr，len以及cap被复制，包括ptr指针将指向同一底层数组。如果修改复制的切片，则会修改相同的共享数组，这将使旧切片和新切片中的所有更改都可见：</description></item><item><title>[Go] 中的陷阱</title><link>https://clannad.icu/blog/3160062725/</link><pubDate>Fri, 24 Sep 2021 03:43:43 +0000</pubDate><guid>https://clannad.icu/blog/3160062725/</guid><description>字符串的长度与数量
// Number of Bytes package main import &amp;quot;fmt&amp;quot; func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(len(data)) } // 7 // 在 Go 中，字符串是 UTF-8 编码的，这意味着每个称为 rune 的字符可以是 1 到 4 个字节长。这里，字符 ♥ 占用 3 个字节，因此字符串的总长度为 7。 // Number of Runes package main import ( &amp;quot;fmt&amp;quot; &amp;quot;unicode/utf8&amp;quot; ) func main() { data := &amp;quot;We♥Go&amp;quot; fmt.Println(utf8.RuneCountInString(data)) } // 5 // 如果要获取字符串中的字符数量，可以使用 unicode/utf8 包。该 RuneCountInString 功能是返回一个字符串的字符数量 用 nil 初始化变量</description></item><item><title>A Bits of Unsolicited Advice</title><link>https://clannad.icu/blog/1213148850/</link><pubDate>Thu, 23 Sep 2021 02:05:12 +0000</pubDate><guid>https://clannad.icu/blog/1213148850/</guid><description>A Bits of Unsolicited Advice Being enthusiastic is worth 25 IQ points.
学习如何从那些你不同意, 甚至冒犯你的人身上学习. 看看你是否能从他们的观点中找到真理
Being enthusiastic is worth 25 IQ points.
热情是值得25个IQ点的
Always demand a deadline. A deadline weeds out the extraneous and the ordinary. It prevents you from trying to make it perfect, so you have to make it different. Different is better.
总是要求有一个最后期限, 一个最后期限可以剔除不相干和普通的东西. 它阻止你试图让它变得完美，所以你必须让它变得不同. 不同就是更好.
Don’t be afraid to ask a question that may sound stupid because 99% of the time everyone else is thinking of the same question and is too embarrassed to ask it.</description></item><item><title>[Go] Goroutines 和 Channels 练习</title><link>https://clannad.icu/blog/1624364114/</link><pubDate>Tue, 07 Sep 2021 07:00:14 +0000</pubDate><guid>https://clannad.icu/blog/1624364114/</guid><description>查找奇数和偶数
/* 查找奇数和偶数 下面的程序启动了两个 Goroutine。这两个 Goroutine 现在并发运行。我们创建了两个无缓冲通道，并将它们作为参数传递给 goroutines，其中包含通道接收到的值。 */ package main func main() { nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} chOdd := make(chan int) chEven := make(chan int) go odd(chOdd) go even(chEven) for _, v := range nums { if v%2 == 0 { chEven &amp;lt;- v } else { chOdd &amp;lt;- v } } } func even(ch chan int) { for v := range ch { println(&amp;quot;偶数: &amp;quot;, v) } } func odd(ch chan int) { for v := range ch { println(&amp;quot;奇数: &amp;quot;, v) } } 启动多个 Goroutines，每个 Goroutine 将值添加到 Channel</description></item><item><title>[Go] defer 理解</title><link>https://clannad.icu/blog/218469985/</link><pubDate>Thu, 02 Sep 2021 06:22:13 +0000</pubDate><guid>https://clannad.icu/blog/218469985/</guid><description>什么是 defer defer 是 Go 语言提供的一种用于注册延迟调用的机智, 每一次 defer 都会把函数压入栈中, 当前函数返回前再把延迟函数取出并执行
defer 语句并不会马上执行，而是会进入一个栈，函数 return 前，会按先进后出（FILO）的顺序执行
先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。
踩坑点 使用 defer 最容易采坑的地方是和带命名返回参数的函数一起使用时。
defer 语句定义时, 对外部变量的引用有两种方式
函数参数: 在 defer 定义时就把值传递给 defer, 并缓存起来 闭包引用: 在 defer 函数被取出调用时根据整个上下文确定当前值 理解 return 语句 return 语句不是原子操作，而是被拆成了两步
val = xxx
return
而 defer 语句就是在这两条语句之间执行，也就是
val = xxx
deferFunc
return
实践检验 package main
import &amp;quot;fmt&amp;quot;
func f1() (r int) {
defer func() {
r++
}()
return 0
}
// 拆分 f1
//func f1() (r int) {
//
// // 1.</description></item><item><title>[Go] Interface</title><link>https://clannad.icu/blog/4229706688/</link><pubDate>Mon, 30 Aug 2021 01:59:22 +0000</pubDate><guid>https://clannad.icu/blog/4229706688/</guid><description>interface类型 interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口
package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string loan float32 } type Employee struct { Human company string money float32 } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func (h *Human) Sing(lyrics string) { fmt.Println(&amp;quot;La la, la la la, la la la la la.</description></item><item><title>[Go] Method</title><link>https://clannad.icu/blog/1110384130/</link><pubDate>Mon, 30 Aug 2021 01:57:38 +0000</pubDate><guid>https://clannad.icu/blog/1110384130/</guid><description>method继承 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.Printf(&amp;quot;Hi, I am %s you can call me on %s\n&amp;quot;, h.name, h.phone) } func main() { mark := Student{Human{&amp;quot;Mark&amp;quot;, 25, &amp;quot;222-222-YYYY&amp;quot;}, &amp;quot;MIT&amp;quot;} sam := Employee{Human{&amp;quot;Sam&amp;quot;, 45, &amp;quot;111-888-XXXX&amp;quot;}, &amp;quot;Golang Inc&amp;quot;} mark.SayHi() sam.SayHi() } method重写 package main import &amp;quot;fmt&amp;quot; type Human struct { name string age int phone string } type Student struct { Human school string } type Employee struct { Human company string } func (h *Human) SayHi() { fmt.</description></item><item><title>[Go] 字符串拼接性能</title><link>https://clannad.icu/blog/3239669741/</link><pubDate>Tue, 24 Aug 2021 02:39:37 +0000</pubDate><guid>https://clannad.icu/blog/3239669741/</guid><description>1. 字符串高效拼接 1.1 为了避免编译器的优化， 首先实现一个生成长度为 n 的随机字符串的函数。 const letterBytes = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot; func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 常见的字符串拼接方式， 以下 5 种
// + func plusConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s += str } return s } // fmt.Sprintf func sprintfConcat(n int, str string) string { s := &amp;quot;&amp;quot; for i := 0; i &amp;lt; n; i++ { s = fmt.</description></item><item><title>Python 面试题(1)</title><link>https://clannad.icu/blog/1745614505/</link><pubDate>Wed, 02 Jun 2021 06:40:12 +0000</pubDate><guid>https://clannad.icu/blog/1745614505/</guid><description>闭包
def multipliers(): return [lambda x: i * x for i in range(4)] print([m(2) for m in multipliers()]) 正确答案 [6, 6, 6, 6]
错误答案 [0, 2, 4, 6]
这个的原因是 Python 的闭包的后期绑定导致的 late binding，这意味着在闭包中的变量是在内部函数被调用的时候被查找。所以结果是，当任何 multipliers() 返回的函数被调用，在那时，i 的值是在它被调用时的周围作用域中查找，到那时，无论哪个返回的函数被调用，for 循环都已经完成了，i 最后的值是 3，因此，每个返回的函数 multiplies 的值都是 3。因此一个等于 2 的值被传递进以上代码，它们将返回一个值 6 （比如：3 x 2）。
# 创建一个闭包，通过使用默认参数立即绑定它的参数 def multipliers(): return [lambda x, i=i : i * x for i in range(4)] # 或者使用 functools.partial 函数 from functools import partial from operator import mul def multipliers(): return [partial(mul, i) for i in range(4)] 默认参数值是可变的</description></item></channel></rss>